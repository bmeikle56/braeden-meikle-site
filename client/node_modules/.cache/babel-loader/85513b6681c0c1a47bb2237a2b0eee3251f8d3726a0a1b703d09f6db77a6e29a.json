{"ast":null,"code":"const user = 'braeden';\nconst BASE_URL = `${process.env.REACT_APP_SERVER_BASE_URL}`;\nconst body = {\n  method: 'GET',\n  headers: {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'no-cache'\n  }\n};\nlet newBytesRead;\n\n/*****     Public APIs     *****/\n\n/*   Get list of byte read/unread statuses   */\nfunction getUnread(setData, setLoading, now) {\n  /*   Server is too slow, so we mock the HTTP request   */\n  setTimeout(() => {\n    setData([1, 1, 1, 1, 1, 1, 1]);\n    setLoading(false);\n  }, 2000);\n\n  /*\n  const service = '/getUnread'\n  fetch(`${BASE_URL}${service}?user=${user}`, body).then(res => res.json()).then(d => { \n    newBytesRead = d.unreadList\n     // We want the screen to animate for minimum 2 seconds\n    if (Date.now() < now + 2000) {\n      setTimeout(() => {\n        setData(d)\n        setLoading(false)\n      }, 2000 - (Date.now() - now))\n    } else {\n      setData(d)\n      setLoading(false)\n    }\n  })\n  */\n}\n\n/*   Mark a byte newly read  */\nfunction markRead(index) {\n  newBytesRead[index] = 0;\n  console.log(newBytesRead);\n}\n\n/*****                     *****/\n\n/*  Before the user leaves, dump and mark all bytes read   */\nwindow.addEventListener('beforeunload', _ => {\n  console.log(newBytesRead);\n  const service = '/read';\n  fetch(`${BASE_URL}${service}?read=${user}`, body);\n});\nexport { getUnread, markRead };","map":{"version":3,"names":["user","BASE_URL","process","env","REACT_APP_SERVER_BASE_URL","body","method","headers","newBytesRead","getUnread","setData","setLoading","now","setTimeout","markRead","index","console","log","window","addEventListener","_","service","fetch"],"sources":["/Users/braedenmeikle/Documents/repo/braeden-meikle-site/client/src/api.js"],"sourcesContent":["\nconst user = 'braeden'\nconst BASE_URL = `${process.env.REACT_APP_SERVER_BASE_URL}`\n\nconst body = {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n      'Cache-Control': 'no-cache'\n    } \n}\n\nlet newBytesRead\n\n/*****     Public APIs     *****/\n\n/*   Get list of byte read/unread statuses   */\nfunction getUnread(setData, setLoading, now) {\n\n  /*   Server is too slow, so we mock the HTTP request   */\n  setTimeout(() => {\n    setData([1,1,1,1,1,1,1])\n    setLoading(false)\n  }, 2000)\n\n  /*\n  const service = '/getUnread'\n  fetch(`${BASE_URL}${service}?user=${user}`, body).then(res => res.json()).then(d => { \n    newBytesRead = d.unreadList\n\n    // We want the screen to animate for minimum 2 seconds\n    if (Date.now() < now + 2000) {\n      setTimeout(() => {\n        setData(d)\n        setLoading(false)\n      }, 2000 - (Date.now() - now))\n    } else {\n      setData(d)\n      setLoading(false)\n    }\n  })\n  */\n}\n\n/*   Mark a byte newly read  */\nfunction markRead(index) {\n  newBytesRead[index] = 0\n  console.log(newBytesRead)\n}\n\n/*****                     *****/\n\n/*  Before the user leaves, dump and mark all bytes read   */\nwindow.addEventListener('beforeunload', _ => {\n  console.log(newBytesRead)\n  const service = '/read'\n  fetch(`${BASE_URL}${service}?read=${user}`, body)\n})\n\nexport { getUnread, markRead }"],"mappings":"AACA,MAAMA,IAAI,GAAG,SAAS;AACtB,MAAMC,QAAQ,GAAG,GAAGC,OAAO,CAACC,GAAG,CAACC,yBAAyB,EAAE;AAE3D,MAAMC,IAAI,GAAG;EACTC,MAAM,EAAE,KAAK;EACbC,OAAO,EAAE;IACP,cAAc,EAAE,kBAAkB;IAClC,eAAe,EAAE;EACnB;AACJ,CAAC;AAED,IAAIC,YAAY;;AAEhB;;AAEA;AACA,SAASC,SAASA,CAACC,OAAO,EAAEC,UAAU,EAAEC,GAAG,EAAE;EAE3C;EACAC,UAAU,CAAC,MAAM;IACfH,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;IACxBC,UAAU,CAAC,KAAK,CAAC;EACnB,CAAC,EAAE,IAAI,CAAC;;EAER;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA,SAASG,QAAQA,CAACC,KAAK,EAAE;EACvBP,YAAY,CAACO,KAAK,CAAC,GAAG,CAAC;EACvBC,OAAO,CAACC,GAAG,CAACT,YAAY,CAAC;AAC3B;;AAEA;;AAEA;AACAU,MAAM,CAACC,gBAAgB,CAAC,cAAc,EAAEC,CAAC,IAAI;EAC3CJ,OAAO,CAACC,GAAG,CAACT,YAAY,CAAC;EACzB,MAAMa,OAAO,GAAG,OAAO;EACvBC,KAAK,CAAC,GAAGrB,QAAQ,GAAGoB,OAAO,SAASrB,IAAI,EAAE,EAAEK,IAAI,CAAC;AACnD,CAAC,CAAC;AAEF,SAASI,SAAS,EAAEK,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}